<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="utf-8" />
        <title>Словари и множества в Python и асимптотика стандартных операций</title>
        <link rel="stylesheet" href="https://mipt-cs.github.io/python3-2017-2018/theme/css/main.css" />
        <link rel="icon" type="image/png" href="https://mipt-cs.github.io/python3-2017-2018/favicon.png" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <div id="wrap">
            <header id="banner" class="body">
                    <img src="https://mipt-cs.github.io/python3-2017-2018/images/logo.svg" class="logo" />
                    <nav><ul>
                        <li><a href="https://mipt-cs.github.io/python3-2017-2018/">Главная</a></li>
                    </ul></nav>
            </header><!-- /#banner -->
            <div id="main"
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://mipt-cs.github.io/python3-2017-2018/labs/lab17.html" rel="bookmark"
           title="Permalink to Словари и множества в Python и асимптотика стандартных операций">Словари и множества в Python и асимптотика стандартных операций</a></h1>
    </header>
      <nav class="toc">
      <div class="toc" id="">

<ul class="simple">
<li><a class="reference internal" href="#id2" id="id19">Введение</a></li>
<li><a class="reference internal" href="#list" id="id20">Список (list)</a><ul>
<li><a class="reference internal" href="#id3" id="id21">Индексирование и присваивание</a></li>
<li><a class="reference internal" href="#pop-shift-delete" id="id22">Pop, Shift, Delete</a></li>
<li><a class="reference internal" href="#id4" id="id23">Итерирование</a></li>
<li><a class="reference internal" href="#id5" id="id24">Срезы</a></li>
<li><a class="reference internal" href="#int" id="id25">Умножение на int</a></li>
<li><a class="reference internal" href="#id6" id="id26">Разворот списка</a><ul>
<li><a class="reference internal" href="#o1" id="id27">Упражнение №1</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#set" id="id28">Множество (set)</a><ul>
<li><a class="reference internal" href="#id7" id="id29">Задание множеств</a></li>
<li><a class="reference internal" href="#id8" id="id30">Работа с элементами множеств</a><ul>
<li><a class="reference internal" href="#o2" id="id31">Упражнение №2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9" id="id32">Операции с множествами, обычные для математики</a><ul>
<li><a class="reference internal" href="#o3" id="id33">Упражнение №3</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#dict" id="id34">Словарь (ассоциативный массив, dict)</a><ul>
<li><a class="reference internal" href="#id10" id="id35">Создание словаря</a></li>
<li><a class="reference internal" href="#id11" id="id36">Операции с элементами словарей</a></li>
<li><a class="reference internal" href="#id12" id="id37">Перебор элементов словаря по ключу</a></li>
<li><a class="reference internal" href="#id13" id="id38">Представления элементов словаря</a></li>
<li><a class="reference internal" href="#id14" id="id39">Пример использования словаря</a></li>
<li><a class="reference internal" href="#id15" id="id40">Трудоемкость стандартных операций</a></li>
<li><a class="reference internal" href="#id16" id="id41">Когда нужно использовать словари</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17" id="id42">Практическая работа по использованию словарей</a><ul>
<li><a class="reference internal" href="#o4" id="id43">Упражнение №4. Подсчет слов</a></li>
<li><a class="reference internal" href="#o5" id="id44">Упражнение №5. Перевод текста</a></li>
<li><a class="reference internal" href="#o6" id="id45">Упражнение №6. Страны и Языки</a></li>
<li><a class="reference internal" href="#o7" id="id46">Упражнение №7*. Сделать русско-английский словарь</a></li>
<li><a class="reference internal" href="#o8" id="id47">Упражнение №8*. Синхронизация словарей</a></li>
<li><a class="reference internal" href="#o9" id="id48">Упражнение №9*. Добродушные соседи</a></li>
<li><a class="reference internal" href="#o10" id="id49">Упражнение №10*. Факультативно: генератор бреда</a></li>
</ul>
</li>
</ul>
</div>
      </nav>
      <br/>
      <br/>
    
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id19">Введение</a></h2>
<p>Понятие сложности алгоритмов уже было рассмотрено в первом семестре, в основном в работах, связанных с сортировками. Цель данной работы понять трудоемкость стандартных процедур в языке python а так же разобраться с думя мощными концепциями - множество(set) и словарь(dict).</p>
<p>Трудоемкость будет рассмотренна на примере встроенных методов и операций классов <code>list, dict, set</code>.</p>
</div>
<div class="section" id="list">
<h2><a class="toc-backref" href="#id20">Список (list)</a></h2>
<p>Для начала вспомним операции работы со списками.</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%"/>
<col width="12%"/>
<col width="21%"/>
<col width="48%"/>
</colgroup>
<tbody valign="top">
<tr><td>Операция</td>
<td>Пример</td>
<td>Трудоемкость</td>
<td>Замечания</td>
</tr>
<tr><td>Взятие индекса</td>
<td>l[i]</td>
<td>O(1)</td>
<td> </td>
</tr>
<tr><td>Сохранение элемента</td>
<td>l[i] = 0</td>
<td>O(1)</td>
<td> </td>
</tr>
<tr><td>Длина</td>
<td>len(l)</td>
<td>O(1)</td>
<td> </td>
</tr>
<tr><td>Добавление в конец</td>
<td>l.append(5)</td>
<td>O(1)</td>
<td> </td>
</tr>
<tr><td>Извлечение с конца</td>
<td>l.pop()</td>
<td>O(1)</td>
<td> </td>
</tr>
<tr><td>Очистка списка</td>
<td>l.clear()</td>
<td>O(1)</td>
<td>Аналогично l = []</td>
</tr>
<tr><td>Срез(Slice)</td>
<td>l[a:b]</td>
<td>O(b-a)</td>
<td> </td>
</tr>
<tr><td>Расширение</td>
<td>l.extend(A)</td>
<td>O(len(A))</td>
<td>Зависит только от длины A</td>
</tr>
<tr><td>Создание</td>
<td>list(A)</td>
<td>O(len(A))</td>
<td>Зависит от длины A (итерируемый объект)</td>
</tr>
<tr><td>Проверка ==, !=</td>
<td>l1 == l2</td>
<td>O(N)</td>
<td> </td>
</tr>
<tr><td>Присваивание в срез</td>
<td>[a:b] = ...</td>
<td>O(N)</td>
<td> </td>
</tr>
<tr><td>Удаление элемента</td>
<td>del l[i]</td>
<td>O(N)</td>
<td> </td>
</tr>
<tr><td>Поиск элемента</td>
<td>x (not) in l</td>
<td>O(N)</td>
<td>Поиск работает за O(N)</td>
</tr>
<tr><td>Копирование списка</td>
<td>l.copy()</td>
<td>O(N)</td>
<td>То же самое что l[:], который O(N)</td>
</tr>
<tr><td>Удаление из списка</td>
<td>l.remove(..)</td>
<td>O(N)</td>
<td> </td>
</tr>
<tr><td>Извлечение элемента</td>
<td>l.pop(i)</td>
<td>O(N)</td>
<td>O(N-i): l.pop(0):O(N) (см. выше)</td>
</tr>
<tr><td>Экстремумы</td>
<td>min(l)/max(l)</td>
<td>O(N)</td>
<td>Поиск работает за O(N)</td>
</tr>
<tr><td>Обращение</td>
<td>l.reverse()</td>
<td>O(N)</td>
<td> </td>
</tr>
<tr><td>Итерирование</td>
<td>for v in l:</td>
<td>O(N)</td>
<td> </td>
</tr>
<tr><td>Сортировка</td>
<td>l.sort()</td>
<td>O(N Log N)</td>
<td> </td>
</tr>
<tr><td>Перемножение</td>
<td>k*l</td>
<td>O(k N)</td>
<td>5*l будет за O(N), len(l)*l будет O(N**2)</td>
</tr>
</tbody>
</table>
<p>У разработчиков типа данных list Python было много вариантов каким сделать его во время реализации. Каждый выбор повлиял на то, как быстро список мог выполнять операции. Одно из решений было сделать список оптимальным для частых операций.</p>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id21">Индексирование и присваивание</a></h3>
<p>Две частые операции - индексирование и присваивание на позицию индекса. В списках Python значения присваиваются и извлекаются из определенных известных мест памяти. Независимо от того, насколько велик список, индексный поиск и присвоение занимают постоянное количество времени и, таким образом их трудоемкость <strong>O(1)</strong>.</p>
</div>
<div class="section" id="pop-shift-delete">
<h3><a class="toc-backref" href="#id22">Pop, Shift, Delete</a></h3>
<p>Извлечение элемента(pop) из списка Python по умолчанию выполняется с конца, но, передавая индекс, вы можете получить элемент из определенной позиции. Когда pop вызывается с конца, операция имеет сложность <strong>O(1)</strong> , а вызов pop из любого места - <strong>O(n)</strong>. Откуда такая разница?</p>
<p>Когда элемент берется из середины списка Python, все остальные элементы в списке сдвигаются на одну позицию ближе к началу. Это суровая плата за возможность брать индекс за <strong>O(1)</strong>, что является более частой операцией.</p>
<p>По тем же причинам вставка в индекс - <strong>O(N)</strong>; каждый последующий элемент должен быть сдвинут на одну позицию ближе к концу, чтобы разместить новый элемент. Неудивительно, что удаление ведет себя таким же образом.</p>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id23">Итерирование</a></h3>
<p>Итерирование выполняется за <strong>O(N)</strong>, потому что для итерации по N элементам требуется N шагов. Это также объясняет, почему оператор in, max, min в Python является <strong>O(N)</strong>: чтобы определить, находится ли элемент в списке, мы должны перебирать каждый элемент.</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id24">Срезы</a></h3>
<p>Чтобы получить доступ к фрагменту [a: b] списка, мы должны перебрать каждый элемент между индексами a и b. Таким образом, доступ к срезу - <strong>O(k)</strong>, где k - размер среза. Удаление среза <strong>O(N)</strong> по той же причине, что удаление одного элемента - <strong>O(N)</strong>: N последующих элементов должны быть смещены в сторону начала списка.</p>
</div>
<div class="section" id="int">
<h3><a class="toc-backref" href="#id25">Умножение на int</a></h3>
<p>Чтобы понять умножение списка на целое k, вспомним, что конкатенация выполняется за <strong>O(M)</strong>, где M - длина добавленного списка. Из этого следует, что умножение списка равно <strong>O(N k)</strong>, так как умножение k-размера списка N раз потребует времени <strong>k (N-1)</strong>.</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id26">Разворот списка</a></h3>
<p>Разворот списка - это <strong>O(N)</strong>, так как мы должны переместить каждый элемент.</p>
<div class="section" id="o1">
<h4><a class="toc-backref" href="#id27">Упражнение №1</a></h4>
<p>Допишите в следующем коде учаток функции, где repeat_count раз повторяется взятие операции pop по индексу pop_position.
Сделается чтобы если pop_position == None то брался pop() без указания индекса. Допишите код получения массивов values1, values2, values3. Покажите преподавателю получившиеся графики.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">get_pop_time</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">repeat_count</span><span class="p">,</span> <span class="n">pop_position</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    size - размер списка из нулей на котором будем тестировать скорость операции pop</span>
<span class="sd">    repeat_count - количество повторений для усреднения</span>
<span class="sd">    pop_position - позиция с которой делаем pop</span>
<span class="sd">    '''</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#</span>
    <span class="c1"># code here</span>
    <span class="c1">#</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">repeat_count</span>

<span class="n">repeat_count</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="c1"># code here</span>
<span class="n">values1</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_pop_time</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)]</span>
<span class="n">values2</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_pop_time</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)]</span>
<span class="n">values3</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_pop_time</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Pop no args'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">values2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Pop start list'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">values3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Pop end list'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'pop time'</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="set">
<h2><a class="toc-backref" href="#id28">Множество (set)</a></h2>
<p>Множество в языке Python — это структура данных, эквивалентная множествам в математике.
Элементы могут быть различных типов. Порядок элементов не определён.</p>
<p>Действия, которые можно выполнять с множеством:</p>
<ol class="arabic simple">
<li>добавлять и удалять элементы,</li>
<li>проверять принадлежность элемента множеству,</li>
<li>перебирать его элементы,</li>
<li>выполнять операции над множествами (объединение, пересечение, разность).</li>
</ol>
<p>Операция “проверить принадлежность элемента” выполняется в множестве <em>намного</em> быстрее, чем в списке.</p>
<p>Элементами множества может быть любой <em>неизменяемый</em> тип данных: числа, строки, кортежи.</p>
<p>Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом множества список (вместо этого используйте <em>неизменяемый</em> кортеж) или другое множество. Требование неизменяемости элементов множества накладывается особенностями представления множества в памяти компьютера.</p>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id29">Задание множеств</a></h3>
<p>Множество задается перечислением в фигурных скобках. Например:</p>
<div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
<p>Исключением явлеется пустое множество:</p>
<div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>       <span class="c1"># A -- множество</span>
<span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>          <span class="c1"># D -- не пустое множество, а пустой словарь!</span>
</pre></div>
<p>Если функции set передать в качестве параметра список, строку или кортеж, то она вернет множество, составленное из элементов списка, строки, кортежа. Например:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'qwerty'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">{</span><span class="s1">'e'</span><span class="p">,</span> <span class="s1">'q'</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">,</span> <span class="s1">'t'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">}</span><span class="o">.</span>
</pre></div>
<p>Каждый элемент может входить в множество только один раз.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">)</span> <span class="c1"># A и B — равные множества.</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">)</span>
<span class="p">{</span><span class="s1">'H'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">,</span> <span class="s1">'l'</span><span class="p">,</span> <span class="s1">'o'</span><span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id30">Работа с элементами множеств</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="15%"/>
<col width="72%"/>
<col width="12%"/>
</colgroup>
<thead valign="bottom">
<tr><th class="head">Операция</th>
<th class="head">Значение</th>
<th class="head">Трудоемкость</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>x in A</code></td>
<td>принадлежит ли элемент <code>x</code> множеству <code>A</code> (возвращают значение типа <code>bool</code>)</td>
<td>O(1)</td>
</tr>
<tr><td><code>x not in A</code></td>
<td>то же, что <code>not x in A</code></td>
<td>O(1)</td>
</tr>
<tr><td><code>A.add(x)</code></td>
<td>добавить элемент <code>x</code> в множество <code>A</code></td>
<td>O(1)</td>
</tr>
<tr><td><code>A.discard(x)</code></td>
<td>удалить элемент <code>x</code> из множества <code>A</code></td>
<td>O(1)</td>
</tr>
<tr><td><code>A.remove(x)</code></td>
<td>удалить элемент <code>x</code> из множества <code>A</code></td>
<td>O(1)</td>
</tr>
<tr><td><code>A.pop()</code></td>
<td>удаляет из множества один случайный элемент и возвращает его</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Как мы видим, по времени стандартные оперцаии с одним элементом множества выполняются за <strong>O(1)</strong>.</p>
<p>Поведение <code>discard</code> и <code>remove</code> различается тогда, когда удаляемый элемент <em>отсутствует</em> в множестве:
<code>discard</code> не делает ничего, а метод remove генерирует исключение <code>KeyError</code>.
Метод <code>pop</code> также генерирует исключение <code>KeyError</code>, если множество пусто.</p>
<p>При помощи цикла for можно перебрать все элементы множества:</p>
<div class="highlight"><pre><span></span><span class="n">Primes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">}</span>
<span class="k">for</span> <span class="n">num</span> <span class="n">im</span> <span class="n">Primes</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</pre></div>
<p>Из множества можно сделать список при помощи функции <code>list</code>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>
<div class="section" id="o2">
<h4><a class="toc-backref" href="#id31">Упражнение №2</a></h4>
<p>Вывести на экран все элементы множества A, которых нет в множестве B.</p>
<div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'bqlpzlkwehrlulsdhfliuywemrlkjhsdlfjhlzxcovt'</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'zmxcvnboaiyerjhbziuxdytvasenbriutsdvinjhgik'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id32">Операции с множествами, обычные для математики</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="27%"/>
<col width="54%"/>
<col width="18%"/>
</colgroup>
<tbody valign="top">
<tr><td>Операция</td>
<td>Значение</td>
<td>Трудоемкость</td>
</tr>
<tr><td> </td>
<td> </td>
<td> </td>
</tr>
<tr><td>A | B
A.union(B)</td>
<td>Возвращает множество, являющееся
объединением множеств A и B.</td>
<td>O(len(A)+len(B))</td>
</tr>
<tr><td>A | = B
A.update(B)</td>
<td>Записывает в A объединение множеств A и B.</td>
<td>O(len(A)+len(B))</td>
</tr>
<tr><td>A &amp; B
A.intersection(B)</td>
<td>Возвращает множество, являющееся
пересечением множеств A и B.</td>
<td>O(min(len(A), len(B))</td>
</tr>
<tr><td>A &amp;= B
A.intersection_update(B)</td>
<td>Записывает в A пересечение множеств A и B.</td>
<td>O(min(len(A), len(B))</td>
</tr>
<tr><td>A - B
A.difference(B)</td>
<td>Возвращает разность множеств A и B
(элементы, входящие в A, но не входящие в B).</td>
<td>O(len(A)+len(B))</td>
</tr>
<tr><td>A -= B
A.difference_update(B)</td>
<td>Записывает в A разность множеств A и B.</td>
<td>O(len(A)+len(B))</td>
</tr>
<tr><td>A ^ B
A.symmetric_difference(B)</td>
<td>Возвращает симметрическую разность множеств A и B
(элементы, входящие в A или в B, но не в оба из них одновременно).</td>
<td>O(len(A)+len(B))</td>
</tr>
<tr><td>A ^= B
A.symmetric_difference_update(B)</td>
<td>Записывает в A симметрическую разность множеств A и B.</td>
<td>O(len(A)+len(B))</td>
</tr>
<tr><td>A &lt;= B
A.issubset(B)</td>
<td>Возвращает True, если A является подмножеством B.</td>
<td>O(len(A))</td>
</tr>
<tr><td>A &gt;= B
A.issuperset(B)</td>
<td>Возвращает True, если B является подмножеством A.</td>
<td>O(len(B))</td>
</tr>
<tr><td>A &lt; B</td>
<td>Эквивалентно A &lt;= B and A != B</td>
<td>O(len(A))</td>
</tr>
<tr><td>A &gt; B</td>
<td>Эквивалентно A &gt;= B and A != B</td>
<td>O(len(B))</td>
</tr>
</tbody>
</table>
<p>В случае, если нужно провести процедуру, затрагивающую все элементы множества, то его трудоемкость будет <strong>O(N)</strong>.</p>
<div class="section" id="o3">
<h4><a class="toc-backref" href="#id33">Упражнение №3</a></h4>
<p>Даны четыре множества:</p>
<div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'0123456789'</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'02468'</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'12345'</span><span class="p">)</span>
<span class="n">D</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">'56789'</span><span class="p">)</span>
</pre></div>
<p>Найти элементы, принадлежащие множеству <code>E</code>:</p>
<img alt="" src="https://mipt-cs.github.io/python3-2017-2018/images/lab17/ex2_formula.png"/>
<!-- E = ((A setminus B) intersection (C setminus D )) union ((D setminus A) intersection (B setminus C ))
LibreOffice Math formula -->
</div>
</div>
</div>
<div class="section" id="dict">
<h2><a class="toc-backref" href="#id34">Словарь (ассоциативный массив, dict)</a></h2>
<p>В массиве или в списке индекс - это целое число.
Традиционной является следующая ситуация:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Sunday'</span><span class="p">,</span> <span class="s1">'Monday'</span><span class="p">,</span> <span class="s1">'Tuesday'</span><span class="p">,</span> <span class="s1">'Wednessday'</span><span class="p">,</span> <span class="s1">'Thursday'</span><span class="p">,</span> <span class="s1">'Friday'</span><span class="p">,</span> <span class="s1">'Saturday'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="s1">'Sunday'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="s1">'Monday'</span>
</pre></div>
<p>А как реализовать обратное соответствие?</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Sunday'</span><span class="p">]</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Monday'</span><span class="p">]</span>
<span class="mi">1</span>
</pre></div>
<p>При помощи списка или массива это сделать невозможно, нужно использовать <strong>ассоциативный массив</strong> или <strong>словарь</strong>.</p>
<p>В словаре индекс может быть <em>любого неизменяемого типа</em>! Индексы, как и сами хранимые значения, задаются явно:</p>
<div class="highlight"><pre><span></span><span class="n">Days</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'Sunday'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">'Monday'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">'Tuesday'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s1">'Wednessday'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">'Thursday'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="s1">'Friday'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s1">'Saturday'</span><span class="p">:</span> <span class="mi">6</span>
<span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Sunday'</span><span class="p">]</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Monday'</span><span class="p">]</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Yesterday'</span><span class="p">]</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="n">File</span> <span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">KeyError</span><span class="p">:</span> <span class="s1">'Yesterday'</span>
</pre></div>
<p>При попытке обратиться к несуществующему элементу ассоциативного массива мы получаем исключение <code>KeyError</code>.</p>
<p>Особенностью ассоциативного массива является его динамичность: в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие элементы.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Yesterday'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">Days</span><span class="p">[</span><span class="s1">'Yesterday'</span><span class="p">])</span>
<span class="o">-</span><span class="mi">1</span>
</pre></div>
<p>При этом размер используемой памяти пропорционален размеру ассоциативного массива. Доступ к элементам ассоциативного массива выполняется хоть и медленнее, чем к обычным массивам, но в целом довольно быстро.</p>
<p>Значения ключей <code>уникальны</code>, двух одинаковых ключей в словаре быть не может. А вот значения могут быть одинаковыми.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Tomorrow'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Yesterday'</span><span class="p">]</span> <span class="o">==</span> <span class="n">Days</span><span class="p">[</span><span class="s1">'Tomorrow'</span><span class="p">]</span>
<span class="bp">True</span>
</pre></div>
<p>Ключом может быть произвольный <em>неизменяемый</em> тип данных: целые и действительные числа, строки, кортежи. Ключом в словаре не может быть множество, но может быть элемент типа frozenset: специальный тип данных, являющийся аналогом типа set, который нельзя изменять после создания. Значением элемента словаря может быть <em>любой</em> тип данных, в том числе и изменяемый.</p>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id35">Создание словаря</a></h3>
<p>Пустой словарь можно создать при помощи функции <code>dict()</code> или пустой пары фигурных скобок <code>{}</code> (вот почему фигурные скобки нельзя использовать для создания пустого множества).</p>
<p>Для создания словаря с некоторым набором начальных значений можно использовать следующие конструкции:</p>
<div class="highlight"><pre><span></span><span class="n">Capitals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Russia'</span><span class="p">:</span> <span class="s1">'Moscow'</span><span class="p">,</span> <span class="s1">'Ukraine'</span><span class="p">:</span> <span class="s1">'Kiev'</span><span class="p">,</span> <span class="s1">'USA'</span><span class="p">:</span> <span class="s1">'Washington'</span><span class="p">}</span>
<span class="n">Capitals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Russia</span> <span class="o">=</span> <span class="s1">'Moscow'</span><span class="p">,</span> <span class="n">Ukraine</span> <span class="o">=</span> <span class="s1">'Kiev'</span><span class="p">,</span> <span class="n">USA</span> <span class="o">=</span> <span class="s1">'Washington'</span><span class="p">)</span>
<span class="n">Capitals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s2">"Russia"</span><span class="p">,</span> <span class="s2">"Moscow"</span><span class="p">),</span> <span class="p">(</span><span class="s2">"Ukraine"</span><span class="p">,</span> <span class="s2">"Kiev"</span><span class="p">),</span> <span class="p">(</span><span class="s2">"USA"</span><span class="p">,</span> <span class="s2">"Washington"</span><span class="p">)])</span>
<span class="n">Capitals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s2">"Russia"</span><span class="p">,</span> <span class="s2">"Ukraine"</span><span class="p">,</span> <span class="s2">"USA"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"Moscow"</span><span class="p">,</span> <span class="s2">"Kiev"</span><span class="p">,</span> <span class="s2">"Washington"</span><span class="p">]))</span>
</pre></div>
<p>Также можно использовать генерацию словаря через Dict comprehensions:</p>
<div class="highlight"><pre><span></span><span class="n">Cities</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Moscow"</span><span class="p">,</span> <span class="s2">"Kiev"</span><span class="p">,</span> <span class="s2">"Washington"</span><span class="p">]</span>
<span class="n">States</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Russia"</span><span class="p">,</span> <span class="s2">"Ukraine"</span><span class="p">,</span> <span class="s2">"USA"</span><span class="p">]</span>
<span class="n">CapitalsOfState</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="p">:</span> <span class="n">city</span> <span class="k">for</span> <span class="n">city</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Cities</span><span class="p">,</span> <span class="n">States</span><span class="p">)}</span>
</pre></div>
<p>Это особенно полезно, когда нужно "вывернуть" словарь наизнанку:</p>
<div class="highlight"><pre><span></span><span class="n">StateByCapital</span> <span class="o">=</span> <span class="p">{</span><span class="n">CapitalsOfState</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span> <span class="n">state</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">CapitalsOfState</span><span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id36">Операции с элементами словарей</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%"/>
<col width="73%"/>
<col width="8%"/>
</colgroup>
<tbody valign="top">
<tr><td>Операция</td>
<td>Значение</td>
<td>Трудоемкость</td>
</tr>
<tr><td>value = A[key]</td>
<td>Получение элемента по ключу. Если элемента с заданным ключом в словаре нет, то возникает исключение KeyError.</td>
<td>O(1)</td>
</tr>
<tr><td>value = A.get(key)</td>
<td>Получение элемента по ключу. Если элемента в словаре нет, то get возвращает None.</td>
<td>O(1)</td>
</tr>
<tr><td>value = A.get(key, default_value)</td>
<td>То же, но вместо None метод get возвращает default_value.</td>
<td>O(1)</td>
</tr>
<tr><td>key in A</td>
<td>Проверить принадлежность ключа словарю.</td>
<td>O(1)</td>
</tr>
<tr><td>key not in A</td>
<td>То же, что not key in A.</td>
<td>O(1)</td>
</tr>
<tr><td>A[key] = value</td>
<td>Добавление нового элемента в словарь.</td>
<td>O(1)</td>
</tr>
<tr><td>del A[key]</td>
<td>Удаление пары ключ-значение с ключом key. Возбуждает исключение KeyError, если такого ключа нет.</td>
<td>O(1)</td>
</tr>
<tr><td><dl class="first last docutils">
<dt>if key in A:</dt>
<dd>del A[key]</dd>
</dl>
</td>
<td>Удаление пары ключ-значение с предварительной проверкой наличия ключа.</td>
<td>O(1)</td>
</tr>
<tr><td><dl class="first last docutils">
<dt>try:</dt>
<dd>del A[key]</dd>
<dt>except KeyError:</dt>
<dd>pass</dd>
</dl>
</td>
<td>Удаление пары ключ-значение с перехватыванием и обработкой исключения.</td>
<td>O(1)</td>
</tr>
<tr><td>value = A.pop(key)</td>
<td>Удаление пары ключ-значение с ключом key и возврат значения удаляемого элемента.Если такого ключа нет, то возбуждается KeyError.</td>
<td>O(1)</td>
</tr>
<tr><td>value = A.pop(key, default_value)</td>
<td>То же, но вместо генерации исключения возвращается default_value.</td>
<td>O(1)</td>
</tr>
<tr><td>A.pop(key, None)</td>
<td>Это позволяет проще всего организовать безопасное удаление элемента из словаря.</td>
<td>O(1)</td>
</tr>
<tr><td>len(A)</td>
<td>Возвращает количество пар ключ-значение, хранящихся в словаре.</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id37">Перебор элементов словаря по ключу</a></h3>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id38">Представления элементов словаря</a></h3>
<p>Представления во многом похожи на списки, но они остаются связанными со своим исходным словарём и изменяются, если менять значения элементов словаря.</p>
<ul class="simple">
<li>Метод <code>keys</code> возвращает представление ключей всех элементов.</li>
<li>Метод <code>values</code> возвращает представление всех значений.</li>
<li>Метод <code>items</code> возвращает представление всех пар (кортежей) из ключей и значений.</li>
</ul>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">'a'</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">'c'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
<span class="p">(</span><span class="n">dict_keys</span><span class="p">([</span><span class="s1">'c'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">]),</span> <span class="n">dict_values</span><span class="p">([</span><span class="s1">'c'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">]))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">[</span><span class="s1">'d'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'a'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
<span class="p">(</span><span class="n">dict_keys</span><span class="p">([</span><span class="s1">'d'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">]),</span> <span class="n">dict_values</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">]))</span>
</pre></div>
<p>Учтите что итерироваться по представлениям изменяя словарь нельзя</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">del</span> <span class="n">A</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">dictionary</span> <span class="n">changed</span> <span class="n">size</span> <span class="n">during</span> <span class="n">iteration</span>
</pre></div>
<p>Можно, если в начале скопировать представление в список</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
<span class="o">...</span>     <span class="k">del</span> <span class="n">A</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="p">{}</span>
</pre></div>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id39">Пример использования словаря</a></h3>
<div class="highlight"><pre><span></span><span class="c1"># Создадим пустой словать Capitals</span>
<span class="n">Capitals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="c1"># Заполним его несколькими значениями</span>
<span class="n">Capitals</span><span class="p">[</span><span class="s1">'Russia'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Moscow'</span>
<span class="n">Capitals</span><span class="p">[</span><span class="s1">'Ukraine'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Kiev'</span>
<span class="n">Capitals</span><span class="p">[</span><span class="s1">'USA'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Washington'</span>

<span class="c1"># Считаем название страны</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'В какой стране вы живете?'</span><span class="p">)</span>
<span class="n">country</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>

<span class="c1"># Проверим, есть ли такая страна в словаре Capitals</span>
<span class="k">if</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">Capitals</span><span class="p">:</span>
    <span class="c1"># Если есть - выведем ее столицу</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Столица вашей страны'</span><span class="p">,</span> <span class="n">Capitals</span><span class="p">[</span><span class="n">country</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Запросим название столицы и добавим его в словарь</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Как называется столица вашей страны?'</span><span class="p">)</span>
    <span class="n">city</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="n">Capitals</span><span class="p">[</span><span class="n">country</span><span class="p">]</span> <span class="o">=</span> <span class="n">city</span>
</pre></div>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id40">Трудоемкость стандартных операций</a></h3>
<p>Второй основной тип данных Python - это словарь. Как вы помните, словарь отличается от списка возможностью доступа к элементам по ключу, а не позиции. На данный момент наиболее важной характеристикой является то, что получение и присваивание элемента в словаре являются операциями за <strong>O(1)</strong>.</p>
<p>Мы не будем пытаться пока дать интуитивное объяснение этому, но будьте уверены, что позже мы обсудим реализации словарей. Пока просто помните, что словари были созданы специально для того, чтобы как можно быстрее получить и установить значения по ключу.</p>
<p>Другая важная операция словаря - проверка наличия ключа в словаре. Операция contains также работает за <strong>O(1)</strong> (в случае со списками это занимало <strong>O(N)</strong>), потому что проверка для данного ключа подразумевает простое получение элемента по ключу, которое делается за <strong>O(1)</strong>.</p>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id41">Когда нужно использовать словари</a></h3>
<p>Словари нужно использовать в следующих случаях:</p>
<ul class="simple">
<li>Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключами являются объекты, а значениями — их количество.</li>
<li>Хранение каких-либо данных, связанных с объектом. Ключи — объекты, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря <code>Num['January'] = 1; Num['February'] = 2; ...</code></li>
<li>Установка соответствия между объектами (например, “родитель—потомок”). Ключ — объект, значение — соответствующий ему объект.</li>
<li>Если нужен обычный массив, но при этом масимальное значение индекса элемента очень велико, но при этом будут использоваться не все возможные индексы (так называемый “разреженный массив”), то можно использовать ассоциативный массив для экономии памяти.</li>
</ul>
</div>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id42">Практическая работа по использованию словарей</a></h2>
<div class="section" id="o4">
<h3><a class="toc-backref" href="#id43">Упражнение №4. Подсчет слов</a></h3>
<p>Дан текст на некотором языке. Требуется подсчитать сколько раз каждое слово входит в этот текст и вывести десять
самых часто употребяемых слов в этом тексте и количество их употреблений.</p>
<p>В качестве примера возьмите файл с текстом лицензионного соглашения Python <code>/usr/share/licenses/python/LICENSE</code>.</p>
<p>Подсказка №1: Используйте словарь, в котором ключ -- слово, а знчение -- количество таких слов.</p>
<p>Подсказка №2: Точки, запятые, вопросы и восклицательные знаки перед обработкой замените пробелами(используйте <a class="reference external" href="https://docs.python.org/2/library/string.html#string.punctuation">punctuation</a> из модуля string).</p>
<p>Подсказка №3: Все слова приводите к нижнему регистру при помощи метода строки <code>lower()</code>.</p>
<p>Подсказка №4: По окончании сбора статистики нужно пробежать по всем ключам из словаря и найти ключ с максимальным значением.</p>
</div>
<div class="section" id="o5">
<h3><a class="toc-backref" href="#id44">Упражнение №5. Перевод текста</a></h3>
<p>Дан словарь <a class="reference external" href="https://mipt-cs.github.io/python3-2017-2018/extra/lab17/task4/en-ru.txt">task4/en-ru.txt</a> с однозначным соответствием английских и русских слов в таком формате:</p>
<blockquote>
<p>cat -   кошка</p>
<p>dog -   собака</p>
<p>mouse   -   мышь</p>
<p>house   -   дом</p>
<p>eats    -   ест</p>
<p>in  -   в</p>
<p>too -   тоже</p>
</blockquote>
<p>Здесь английское и русское слово разделены двумя табуляциями и минусом: <code>'\t-\t'</code>.</p>
<p>В файле <a class="reference external" href="https://mipt-cs.github.io/python3-2017-2018/extra/lab17/task4/input.txt">task4/input.txt</a> дан текст для перевода, например:</p>
<div class="line-block">
<div class="line">Mouse in house. Cat in house.</div>
<div class="line">Cat eats mouse in dog house.</div>
<div class="line">Dog eats mouse too.</div>
</div>
<p>Требуется сделать подстрочный перевод с помощью имеющегося словаря и вывести результат в <code>output.txt</code>.
Незнакомые словарю слова нужно оставлять в исходном виде.</p>
</div>
<div class="section" id="o6">
<h3><a class="toc-backref" href="#id45">Упражнение №6. Страны и Языки</a></h3>
<p>Дан список стран и языков на которых говорят в этой стране в формате <code>&lt;Название Страны&gt; : &lt;язык1&gt; &lt;язык2&gt; &lt;язык3&gt; ...</code> в файле <a class="reference external" href="https://mipt-cs.github.io/python3-2017-2018/extra/lab17/task5/input.txt">task5/input.txt</a>. На ввод задается N - длина списка и список языков. Для каждого языка укажите, в каких странах на нем говорят.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%"/>
<col width="50%"/>
</colgroup>
<thead valign="bottom">
<tr><th class="head">Ввод</th>
<th class="head">Вывод</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>3</td>
<td> </td>
</tr>
<tr><td>азербайджанский</td>
<td>Азербайджан</td>
</tr>
<tr><td>греческий</td>
<td>Кипр Греция</td>
</tr>
<tr><td>китайский</td>
<td>Китай Сингапур</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="o7">
<h3><a class="toc-backref" href="#id46">Упражнение №7*. Сделать русско-английский словарь</a></h3>
<p>В файле <a class="reference external" href="https://mipt-cs.github.io/python3-2017-2018/extra/lab17/task6/en-ru.txt">task6/en-ru.txt</a> находятся строки англо-русского словаря в таком формате:</p>
<div class="line-block">
<div class="line">cat    -   кошка</div>
<div class="line">dog    -   собака</div>
<div class="line">home   -   домашняя папка, дом</div>
<div class="line">mouse  -   мышь, манипулятор мышь</div>
<div class="line">to do  -   делать, изготавливать</div>
<div class="line">to make    -   изготавливать</div>
</div>
<p>Здесь английское слово (выражение) и список русских слов (выражений) разделены двумя табуляциями и минусом: <code>'\t-\t'</code>.</p>
<p>Требуется создать русско-английский словарь и вывести его в файл <code>ru-en.txt</code> в таком формате:</p>
<div class="line-block">
<div class="line">делать -   to do</div>
<div class="line">дом    -   home</div>
<div class="line">домашняя папка -   home</div>
<div class="line">изготавливать  -   to do, to make</div>
<div class="line">кошка  -   cat</div>
<div class="line">манипулятор мышь   -   mouse</div>
<div class="line">мышь   -   mouse</div>
<div class="line">собака -   dog</div>
</div>
<p>Порядок строк в выходном файле должен быть словарным с <em>человеческой</em> точки зрения (так называемый <em>лексикографический</em> порядок слов). То есть выходные строки нужно отсортировать.</p>
</div>
<div class="section" id="o8">
<h3><a class="toc-backref" href="#id47">Упражнение №8*. Синхронизация словарей</a></h3>
<p>Даны два файла словарей: <a class="reference external" href="https://mipt-cs.github.io/python3-2017-2018/extra/lab17/task7/en-ru.txt">task7/en-ru.txt</a> и <a class="reference external" href="https://mipt-cs.github.io/python3-2017-2018/extra/lab17/task7/ru-en.txt">task7/ru-en.txt</a> (в формате, описанном в упражнении №6).</p>
<p>en-ru.txt:</p>
<div class="line-block">
<div class="line">home   -   домашняя папка</div>
<div class="line">mouse  -   манипулятор мышь</div>
</div>
<p>ru-en.txt:</p>
<div class="line-block">
<div class="line">дом    -   home</div>
<div class="line">мышь   -   mouse</div>
</div>
<p>Требуется синхронизировать и актуализировать их содержимое.</p>
<p>en-ru.txt:</p>
<div class="line-block">
<div class="line">home   -   домашняя папка, дом</div>
<div class="line">mouse  -   манипулятор мышь, мышь</div>
</div>
<p>ru-en.txt:</p>
<div class="line-block">
<div class="line">дом    -   home</div>
<div class="line">домашняя папка     -   home</div>
<div class="line">манипулятор мышь   -   mouse</div>
<div class="line">мышь   -   mouse</div>
</div>
</div>
<div class="section" id="o9">
<h3><a class="toc-backref" href="#id48">Упражнение №9*. Добродушные соседи</a></h3>
<p>В одном очень дружном доме, где живет Фёдор, многие жильцы оставляют ключи от квартиры соседям по дому, например на случай пожара или потопа, да и просто чтобы покормили животных или полили цветы.</p>
<p>Вернувшись домой после долгих странствий, Фёдор обнаруживает, что потерял свои ключи и соседей дома нет. Но вдруг у домофона он находит чужие ключи. Помогите Федору найти ключи от своей квартиры в квартирах соседей.</p>
<p>На ввод подается файл input.txt, в котором в первой строке записано три числа через пробел N - номер квартиры Фёдора, M - номер квартиры от которой Федор нашел ключи, K - ключ от этой квартиры. Далее i-я строка хранит описание ключей запертых в i-й квартире в формате <code>&lt;m_i0 - номер квартиры&gt; &lt;k_i0 - ключ&gt;,&lt;m_i1 - номер квартиры&gt; &lt;k_i1 - ключ&gt;,...</code> , причем реальные номера квартир "зашифрованы" ключем от i-й квартиры(Ki) и находятся по формуле m_ij' = m_ij - Ki. Номера квартир начинаются с 0 (кпримеру вторая строка файла соответствует 0-й квартире).</p>
<p>Нужно вывести ключ от квартиры Федора или None если его найти не получилось.</p>
<table border="1" class="docutils">
<colgroup>
<col width="71%"/>
<col width="29%"/>
</colgroup>
<thead valign="bottom">
<tr><th class="head">Ввод</th>
<th class="head">Вывод</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>4 0 1</td>
<td>1</td>
</tr>
<tr><td>1 1,2 0,3 1,4 0</td>
<td> </td>
</tr>
<tr><td>3 0</td>
<td> </td>
</tr>
<tr><td>5 1,6 0</td>
<td> </td>
</tr>
<tr><td> </td>
<td> </td>
</tr>
<tr><td>1 1</td>
<td> </td>
</tr>
<tr><td>2 1</td>
<td> </td>
</tr>
</tbody>
</table>
<p>Подсказка: используйте словарь для хранения ключей от еще не открытых комнат и множество для уже проверенных комнат.</p>
</div>
<div class="section" id="o10">
<h3><a class="toc-backref" href="#id49">Упражнение №10*. Факультативно: генератор бреда</a></h3>
<p>Дан текст-образец, по которому требуется сделать <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0">генератор случайного бреда</a> на основе Марковских цепей.</p>
<p>Подробности спрашивайте у семинариста.</p>
</div>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
                <section id="extras" class="body">
                </section><!-- /#extras -->
            </div>
        </div>

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Сайт построен с использованием <a href="http://getpelican.com/">Pelican</a>. За основу оформления взята тема от <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>. Исходные тексты программ, приведённые на этом сайте, распространяются под лицензией <a href="http://www.gnu.org/licenses/quick-guide-gplv3.en.html">GPLv3</a>, все остальные материалы сайта распространяются под лицензией <a href="http://creativecommons.org/licenses/by-sa/3.0/deed.ru">CC-BY-SA</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->

</body>
</html>